using System.Collections.Generic;

namespace RecipeLib
{
	public static class RecipeHelp
	{
		public static readonly string[] Commands = {
			@"#!         | alias for #put",
			@"##         | alias for #recipe",
			@"#$         | alias for #with (think $ for $tring manipulation $cript)",
			@"#.         | alias for #info",
			@"#@         | alias for #cdata",
			@"#after     | insert after regex in macro or files: #after rx [-r ]path\pattern ... #end",
			@"#append    | add to the end of a macro or files: #append m m1 m2...; #append macro ... #end; #append [-r ]path\pattern ... #end",
			@"#ask       | ask user for input; input is text or multiple choice #ask a=question; #ask a/q/-/opt1|text1/opt2|text2/.../#end",
			@"#assert    | #assert macro regex: stop execution of recipe stack if condition false",
			@"#auto      | first line in recipe: autorun recipe (dclick in Explorer, if associated .rcp extension)",
			@"#before    | insert before regex in macro or files: #before rx [-r ]path\pattern ... #end",
			@"#call      | obsolete, alias for cmd",
			@"#cdata     | treat value as unparsed character data and store in dictionary, #cdata macro ... #end macro",
			@"#cmd       | run a program, wait until it finishes; or run here-text in cmd shell; assign output: #cmd a ... #end",
			@"#copy      | copy to clipboard: #copy text; #copy ... #end",
			@"#count     | count lines/chars in macro, bytes/kb/lines in file, files in folder, e.g. #count n=c:\temp *.txt, #count n=c:\temp\a.txt lines",
			@"#csharp    | compile and execute the here-text as the body of a C# method. Assign result string to given key. #csharp key ... #end",
			@"#date      | date format and time zone conversions. #date rx macro/paths // parse-fmt // tz-from // tz-to // out-fmt // #end",
			@"#decrypt   | decrypt text in macro with given key",
			@"#def       | define custom command, #def cmd-name [arg1 arg2 ...] .. #enddef, invoke by #cmd-name retval // val1 // val2 ... #end",
			@"#default   | put macro in dictionary only if not exists",
			@"#del       | delete file:  #del [-r ]path\pattern",
			@"#dir       | #dir m=[-r ]path\pattern: get files in directory, assign to macro",
			@"#do        | modify file, expand macros:  #do [-r ]path\pattern",
			@"#edit      | put contents of macro in editor window",
			@"#email     | send email, requires `smtp-sender`, `smtp-host`",
			@"#encrypt   | encrypt text in macro with given key",
			@"#error     | raise an error; the arg will be stored in macro `errormsg` and execute will proceed in a handler registerd by #trap",
			@"#esc       | escape a string for use in a Regex search: #esc a=(hello...)  -> \(hello\.\.\.\)",
			@"#escxml    | escape xml or html string, e.g. & -> &amp;  ' -> &apos;",
			@"#exists    | checks if an item exists as 'macro', 'file' or 'dir' -> these values get assigned to the variable, '' if not found",
			@"#exit      | exit recipe tool",
			@"#exp       | expand macros inside given macro: #exp template",
			@"#expn      | expand the arg template for each line in the here-text, which contains key1=val1|key2=val2|...",
			@"#extract   | find regex in macro or files and generate here-text for each match in the file or macro: #extract rx (path|macro)... #end",
			@"#fatal     | raise a fatal error; this will always result in stopping the recipe stack regardless of the #return in the #trap",
			@"#find      | obsolete, use #extract",
			@"#for       | #for format min step max .. #next: for-loop using `_` as loop variable e.g. #for 000 1 1 10 // #write `_` // #next",
			@"#forget    | remove macro from dictionary",
			@"#git       | run git commands, assign output to first arg: #put repo=...; #git a=status; #git a ... #end; `repo` is required path",
			@"#if        | if macro regex // else // endif",
			@"#ifnot     | ifnot macro regex // else // endif",
			@"#indentxml | #indentxml [-r] path\*.ext",
			@"#info      | print text in log or console: #info The answer = `a`",
			@"#intersect | #intersect m=m1 m2 m3... -  intersection of lines",
			@"#iter      | exec a recipe passing each line as arg: 1. #iter list recipe; 2. #iter list // recipe using `_` to represent line // #next",
			@"#line      | print line number and scope name and any comment for debugging;  #line Delete files...",
			@"#load      | load content of file or webpage and store in dictionary",
			@"#makexml   | make xml from a lite-xml syntax that uses tabs for indent and omits < /> '...'",
			@"#map       | apply dictionary to macro or files; dictionary is macro with key|value lines: #map dict [-r ]path\pattern; #map dict m",
			@"#marker    | marker name to search for when using #do",
			@"#mbox      | pop up text in box",
			@"#mkdir     | #mkdir path ... #end: create folder +copy/move files; #mkdir -f path -> force overwrite unless readonly",
			@"#mode      | #mode write -> changes to write mode, #mode test -> changes to test mode",
			@"#name      | obsolete, alias for #marker",
			@"#new       | create file if new and copy following lines upto #end into it",
			@"#newer     | create or replace file and copy following lines upto #end into it",
			@"#path      | #path result // path parts to be combined... // #end",
			@"#pause     | sleep for given milliseconds",
			@"#point     | obsolete, use #stash",
			@"#post      | http post of here-text to given server",
			@"#print     | write text to output; #print this line; #print ... #end",
			@"#printv    | print the value of the given macro: #printv macro; for use inside #if, #for, #iter, etc.",
			@"#product   | #product m=m1 m2 - carthesian product of two lists",
			@"#ps        | run a powershell program, wait till it finishes; assign output; #ps a=dir|get-member;  #ps a ... #end",
			@"#put       | put macro in dictionary: #put a=macro; #put a ... #end",
			@"#putm      | #putm macro: the macro contains lines like key=value; put these in the dictionary",
			@"#putv      | put macro in dictionary, treat value as a lookup key and put the value of that one in dict",
			@"#putx      | like putv, but expand the value before storing",
			@"#rand      | define a random number generator: #rand key fmt min max seed",
			@"#recipe    | call given recipe (macro or file) and optionally assign return value: #recipe macro; #recipe retval=path;",
			@"#repeat    | #repeat macro n",
			@"#require   | throw exception if macro does not exist",
			@"#restore   | restore all macros remembered with #stash",
			@"#return    | return to caller, optionally pass a value: #return `val`",
			@"#rmdir     | remove folders: #rmdir regex rootdir",
			@"#run       | run a program, don't wait for it to finish: #run {path} args",
			@"#seq       | define a sequence number generator: #seq key fmt min step max",
			@"#server    | server mode: run recipe commands for each incoming http request",
			@"#sort      | #sort rx macro-or-files",
			@"#stash     | restore point: remember all the macros",
			@"#stop      | stop execution of recipe stack, do not exit GUI tool; optionally provide stop condition: #stop macro regex",
			@"#subs      | substitute regex in macro or files: #subs rx [-r ]path\pattern ... #end",
			@"#subtract  | #subtract m=m1 m2 m3... -  subtraction of lines",
			@"#tags      | one ore more tags for the RecipeGUI File>Search #tags function",
			@"#trap      | #trap rcp rx; when the `errormsg` matches rx then exec rcp; #return stop|up|next in the rcp, ignored by #fatal",
			@"#treecopy  | #treecopy source-dir > dest-dir; copies entire folder structure",
			@"#udp       | send here-text as udp to addr port",
			@"#union     | #union m=m1 m2 m3... -  union of lines, remove duplicates",
			@"#unique    | skip lines that already have the regex",
			@"#until     | #until macro regex .. #loop, keep looping until macro matches regex",
			@"#version   | stop execution if program version mismatch; e.g. #version 1.5+, #version 1.5-, #version 1.5; note: +(>=) -(<)",
			@"#warn      | pop up warning and ask whether to continue or cancel execution",
			@"#watch     | file system watcher",
			@"#while     | #while macro regex .. #loop, keep looping while macro matches regex",
			@"#with      | apply script operations on the macro or files, #with a ... #end or #with a=(single oper)",
			@"#wrestart  | restart a windows service",
			@"#write     | obsolete, use print",
			@"#wstart    | start a windows service, uses `wtimeout` in seconds e.g. #wstart Recipe Service",
			@"#wstop     | stop a windows service",
			@"#xcopy     | identical to #cmd {xcopy} args...",
		};

		public static readonly Dictionary<string, string> ScriptOperations = new Dictionary<string, string> {

			{"append text",              @"unescape the arg text and append it"},
			{"chksum",                   @"8-bit ASCII checksum of the input"},
			{"chomp",                    @"trim any string of \t, \r, \n from the end of the text "},
			{"col /sep/columns",         @"select/reorder columns, look for sep; columns: space-separated ordinals of columns to select, *=remaining, +=next e.g.  /,/1 3 + ...all but #2"},
			{"count",                    @"list unique lines and put number of occurrences then ""|"" then line"},
			{"crlf",                     @"make line endings -\r- -\n- -\r\r\n- -\r\n- all like -\r\n- "},
			{"delblank",                 @"delete all blank lines"},
			{"enclose text-with-[]",     @"replace each line with the given text but substitute any occurrence of ""[]"" in the argument with the original line"},
			{"esc",                      @"change newline=>\n carriage-return=>\r tab=>\t backslash=>\\"},
			{"etrim chars",              @"trim given chars off end of string, default chars are space and tab"},
			{"first regex",              @"find first match of regex, if contains capture-groups, return first group, or else return total match"},
			{"frombase64",               @"interpret text as base-64 encoded"},
			{"fromcsv [sep]",            @"convert from comma separated values to use another separator (default ""|""), unescape \"" and """""},
			{"fromuni",                  @"unescapes all \uXXXX to the actual character where XXXX is Unicode hex"},
			{"fromxx",                   @"unescape \XX chars, where XX is ASCII hex code"},
			{"indentxml indent-string",  @"interpret text as XML, format it, using given indentation string (default tab)"},
			{"info [text]",              @"print the given text or else the intermediate result"},
			{"insert n line",            @"insert the given line of text after every n'th line from the input"},
			{"join /regex/sep/mode",     @"group the lines separated by lines that matches the regex, put them on one line using the given separator (default ""|"")"},
			{"join [n [sep]]",           @"join every n (default 2) lines into one line, using the given (unescaped) separator (default "" "")"},
			{"join [sep]",               @"join all lines into one line adding the optional separator in between"},
			{"line i [n]",               @"select the lines in the range [i, i+n-1]; n is 1 by default, i is 0-based; negative i counted from end"},
			{"linenum format",           @"prefix with line numbers starting at 1, replace ""[]"" in format by the number"},
			{"makeguid [string]",        @"find each occurrence of the given string (default ""GUID"") and replace by a Guid"},
			{"match regex",              @"remove all lines that do not contain a match of the regex"},
			{"md5ascii",                 @"calculate MD5 checksum, use ASCII encoding"},
			{"md5utf8",                  @"calculate MD5 checksum, use UTF8 encoding"},
			{"modify /regex/func/mode",  @"change matched text, functions: ^=>uppercase, v=>lowercase, trim, compact=>change whitespace to single space, scc=>space-camelcase, more... see source"},
			{"nomatch regex",            @"remove all lines that contain a match of the regex"},
			{"num s fmt start step end", @"find each occurence of the string  s and replace it by a sequence number, default string=""NUM"", format=""0"", start=1, step=1, end=maxvalue"},
			{"pad char[(+|-)length]",    @"pad each line with a given char: .+5 pad with ""."" 5 beyond max length, x-3, pad with ""x"" 3 less than max length; default is "" +0"": use space, pad to max length"},
			{"path function",            @"interpret each line as a path and apply function: file=>filename, dir=>directory, ext=>extention, root=>root/drive, noext=>fn w/o ext"},
			{"prefix text",              @"prefix each line with the given text"},
			{"repeat n",                 @"repeat the text n times"},
			{"replace",                  @"alias for ""subs"""},
			{"reverse",                  @"reverse the line order"},
			{"sclip macro regex",        @"replace a pattern in each line in the text with a line in a macro, restart line 0 if less lines than matches"},
			{"sha1ascii",                @"calculate SHA-1 checksum, use ASCII encoding"},
			{"sha1utf8",                 @"calculate SHA-1 checksum, use UTF8 encoding"},
			{"sha256ascii",              @"calculate SHA-256 checksum, use ASCII encoding"},
			{"sha256utf8",               @"calculate SHA-256 checksum, use UTF8 encoding"},
			{"sha512ascii",              @"calculate SHA-512 checksum, use ASCII encoding"},
			{"sha512utf8",               @"calculate SHA-512 checksum, use UTF8 encoding"},
			{"sort regex",               @"sort the lines, using the first capture group as the string to sort on"},
			{"split [sep]",              @"split the line on the given string (default a "" "") into multiple lines"},
			{"store macro",              @"put the intermediate result of the script into the dictionary"},
			{"strim chars",              @"trim given chars off start of string, default chars are space and tab"},
			{"subs /regex/repl/mode",    @"find each match of the regex with the replacement; ""/"" can be replaced by any other separator; mode-chars: s m i n x"},
			{"suffix text",              @"append the given text to each line"},
			{"table /sep/sep2/options",  @"format a table from the text, sep=column separator, replace by sep2; opt: n=>eq num col, w=>eq width, r=>right align all, z=>right align num"},
			{"template template-line",   @"take ""|""-separated values found in text lines and fill in in template-line as $1, $2, $3..., $# is 1-based seq number"},
			{"tobase64",                 @"turn text into UTF8 encoded base-64"},
			{"tocsv [sep]",              @"convert lines with given separator (default "","") to CSV format, using "".."" and escape "" where necessary"},
			{"touni",                    @"escapes all characters with code > 127 as \uXXXX where XXXX is Unicode hex"},
			{"toxx [chars]",             @"escape chars outside the range [32, 127] and any specified chars as \XX where XX is ASCII hex code"},
			{"trim chars",               @"trim given chars off start and end of string, default chars are space and tab"},
			{"twocol sep",               @"format the text into two columns based on the separator"},
			{"unesc",                    @"change  \r=>carriage-return \n->newline \t->tab \s->space \\->backslash"},
			{"unique",                   @"remove duplicate lines"},
			{"validate regex",           @"apply regex to each line and output per line: number of matches, then ""|"", then the line"},
			{"wrap [length]",            @"line wrap, arg is the max length of a line, default 40"},
			{"xguid sep",                @"extract all GUIDs, when more on 1 line, use given separator in between"},
			{"xmatch regex",             @"extract all matches of the regex, output one match per line"},
		};
	}
}